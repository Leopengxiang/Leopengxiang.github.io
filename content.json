{"meta":{"title":"锅盖的博客","subtitle":null,"description":null,"author":"Leo Px","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About me","date":"2019-12-13T03:50:06.000Z","updated":"2019-12-13T03:53:50.820Z","comments":true,"path":"about/me.html","permalink":"http://yoursite.com/about/me.html","excerpt":"","text":"生活如此多娇"}],"posts":[{"title":"第三章","slug":"第三章","date":"2019-12-13T03:56:23.964Z","updated":"2019-11-28T15:09:57.890Z","comments":true,"path":"2019/12/13/第三章/","link":"","permalink":"http://yoursite.com/2019/12/13/%E7%AC%AC%E4%B8%89%E7%AB%A0/","excerpt":"","text":"第三章 JDK并发包 相关同步控制工具的介绍 JDK中对线程池的支持 JDK中的一些并发容器 1 同步控制工具同步控制是并发程序中必不可少的重要手段。接下来将依次介绍JDK并发包(java.util.concurrent)中几种常用的同步控制工具。 1.1 重入锁和Condition的搭配重入锁使用java.util.concurrent.locks.ReentrantLock类来实现, 重入锁是synchronized关键字的增强版，它完全可以替代synchronized关键字，且在JDK版本早于5.0的版本里，ReentrantLock的性能完爆synchronized关键字。与synchronized关键字相比重入锁有着显示的操作过程，开发人员必须手动指定何时加锁，合适释放锁。因此重入锁对逻辑控制的灵活度远高于synchronized关键字。如果一个线程多次加锁，那么也必须释放相同的次数。 重入锁程序简单示例1234567891011121314151617181920212223242526272829303132package chapter3;import java.util.concurrent.locks.ReentrantLock;public class ReenterLock implements Runnable &#123; private static ReentrantLock lock = new ReentrantLock(); private static int i = 0; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; lock.lock(); try &#123; i++; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main (String[] args) throws InterruptedException &#123; ReenterLock rl = new ReenterLock(); Thread t1 = new Thread(rl); Thread t2 = new Thread(rl); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125;&#125; 重入锁“重入”特性同一个线程连续多次获得同一把锁是被允许的。 如下代码所示： 12345678lock.lock();lock.lock();try &#123; i++&#125; finally &#123; lock.unlock(); lock.unlock();&#125; 与synchronized关键字相比重入锁的高级特性 中断响应 中断响应是通过在加锁的时候使用lockInterruptibly()方法来实现的。 示例程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 package chapter3;import java.util.concurrent.locks.ReentrantLock;public class IntLock implements Runnable &#123; private static ReentrantLock lock1 = new ReentrantLock(); private static ReentrantLock lock2 = new ReentrantLock(); int lock; /** * 控制加锁顺序，方便构造死锁 * @param lock */ public IntLock(int lock) &#123; this.lock = lock; &#125; @Override public void run() &#123; try &#123; if (lock == 1) &#123; lock1.lockInterruptibly(); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock2.lockInterruptibly(); &#125; else &#123; lock2.lockInterruptibly(); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock1.lockInterruptibly(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (lock1.isHeldByCurrentThread()) &#123; lock1.unlock(); System.out.println(\"unlock lock1\"); &#125; if (lock2.isHeldByCurrentThread()) &#123; lock2.unlock(); System.out.println(\"unlock lock2\"); &#125; System.out.println(Thread.currentThread().getName() + \"线程退出\"); &#125; &#125; / 无论try块是正常执行，finally块中的语句总是会执行 public static void main(String[] args) throws InterruptedException &#123; IntLock r1 = new IntLock(1); IntLock r2 = new IntLock(2); Thread t1 = new Thread(r1, \"t1\"); Thread t2 = new Thread(r2, \"t2\"); t1.start(); t2.start(); Thread.sleep(1000); t2.interrupt(); &#125;&#125; t2.interrupt()打破了死锁的状态，t2放弃了对lock1的请求，退出并释放了lock2。从而t1得到了lock2, 完成了任务，正常退出了。 程序结果： 锁申请限时等待除了等带外部通知之外，要避免死锁还有另一种方法，那就是限时等待。通常我们无法判断一个线程为何迟迟拿不到锁。也许是因为死锁了也许是因为产生了饥饿。给定一个等待时间让线程自动放弃。我们可以使用tryLock()方法进行一次限时等待。 1boolean tryLock(long time, TimeUnit unit) 当ReentrantLock.tryLock()不带任何参数时，即不等待，拿到锁就立即返回true, 拿不到锁就就直接返回false。 1234567891011121314151617181920212223242526272829303132package chapter3;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantLock;public class TimeLock implements Runnable &#123; public static ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; try &#123; if (lock.tryLock(5, TimeUnit.SECONDS)) &#123; System.out.println(Thread.currentThread().getName() + \" get lock\"); Thread.sleep(6000); &#125; else &#123; System.out.println(Thread.currentThread().getName() + \" get lock failed\"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (lock.isHeldByCurrentThread()) &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(new TimeLock(), \"t1\"); Thread t2 = new Thread(new TimeLock(), \"t2\"); t1.start(); t2.start(); &#125;&#125; 程序运行结果： 公平锁公平锁： 按照时间顺序先到先得，不会产生饥饿，只要你排队最终就能获得资源。实现公平锁需要维护一个有序队列，实现成本高，效率低下。所以默认一般时非公平锁。但是重入锁提供了一个如下的构造函数可以实现公平锁。 1public ReentrantLock(boolean fair) 重入锁的实现中的三个要素 原子状态。原子状态使用CAS(Compare and Swap)操作来存储当前锁的状态，判断锁是否已经被别的线程持有了。 等待队列。所有没有请求到锁的线程，会进入等待队列进行等待。待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作。 阻塞原语park()和unpark()，用来挂起和恢复线程。没有得到锁的线程将会被挂起。 重入锁的好搭档:Condition通过lock接口（重入锁就实现了这一接口）的Condition newCondition()方法可以生成一个与当前重入锁绑定的Condition实例，利用Condition对象，我们可以让线程在合适的时间等待，或者特定的时间得到通知，继续执行。Condition 接口提供的基本方法如下： 123456void await() throws InterruptedException;void awaitUninterruptibly();long awaitNanos(long nanosTimeout) throws InterruptedException;boolean await(long time, TimeUnit unit) throws InterruptedException;void signal();void signalAll(); 12345678910111213141516171819202122232425262728public class ReenterLockCondition implements Runnable &#123; public static ReentrantLock lock = new ReentrantLock(); public static Condition condition = lock.newCondition(); @Override public void run() &#123; try &#123; lock.lock(); System.out.println(\"hello\"); condition.await(); // 会释放掉锁 System.out.println(\"Thread is going on\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ReenterLockCondition tl = new ReenterLockCondition(); Thread t1 = new Thread(tl); t1.start(); Thread.sleep(3000); lock.lock(); // main线程必须先持有锁才调用condition.signal(); condition.signal(); lock.unlock(); &#125;&#125; 1.3 信号量(Semaphore)-允许多个线程同时访问从广义上说，信号量时对锁的扩展。无论是内部锁synchronized还是重入锁ReentrantLock，一次都只允许一个线程访问一个资源。而信号量却可以指定多个线程，同时访问某一资源。信号量的主要构造函数 12public Semaphore(int permits)public Semaphore(int permits, boolean fair) // 第二个参数可以指定是否公平 信号量的主要逻辑方法 12345public void acquire() // 尝试获得一个许可public void acquireUninterruptibly()public boolean tryAcquire()public boolean TryAcquire(long timeout, TimeUnit unit)public void release() // 线程访问资源结束后释放一个许可 12345678910111213141516171819202122232425262728293031323334package chapter3;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class SemapDemo implements Runnable &#123; final Semaphore semp = new Semaphore(5); // 利用Semaphore，假如线程池中的线程够用的话，将会5个一组同时访问资源 @Override public void run() &#123; try &#123; semp.acquire(); Thread.sleep(2000); System.out.println(Thread.currentThread().getId() + \":done!\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semp.release(); &#125; &#125; public static void main(String[] args) &#123; ExecutorService exec = Executors.newFixedThreadPool(20); // 构造具有coresize = 20 的线程池 final SemapDemo demo = new SemapDemo(); for (int i = 0; i &lt; 20; i++) &#123; exec.submit(demo); &#125; exec.shutdown(); // 关闭线程池 &#125;&#125; 1.4 ReadWriteLock 读写锁ReadWriteLock是JDK5中提供的读写分离锁。读写分离锁可以有效的帮助减少锁的竞争，提升性能。读读操作可以是并行操作，但是一旦含有写操作就只能是串行操作。如果在系统中，读的操作远远大于写的操作，则读写锁可以发挥最大的功效，提升系统的性能。 1.5 倒计数器：CountDownLatchCountDownLatch是一个非常实用的多线程控制工具类，通常用来控制线程等待，它可以让某一个线程等待直到倒计数结束，再开始执行。CountDownLatch的构造函数接受一个整数作为参数，即当前这个计数器的计数个数。 123public CountDownLatch(int count) // 构造函数public void countDown() // 计数器减一 2 线程复用：线程池2.1 什么是线程池？线程复用的原因： 系统频繁的创建和销毁线程， 耗费大量时间 再实际生产环境中，线程的数量必须得到控制。盲目创建大量线程会抢占宝贵的内存空间，如果处理不当会导致Out of Memory异常。即便没有，大量的线程回收也会给GC带来很大压力，延长GC的停顿时间。 线程池就是一个线程管理工具，能够做到线程复用，使用线程池后，创建线程变成了从线程池中获得空闲线程，关闭线程变成了向线程池归还线程。 2.2 JDK对线程池的支持","categories":[],"tags":[]}]}